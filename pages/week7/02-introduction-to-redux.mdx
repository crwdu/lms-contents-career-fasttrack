import { Alert } from "antd";
import { Callout } from "nextra-theme-docs";

# 리덕스 주요개념

자바스크립트 Single Page Application이 점점 복잡해짐에 따라, 우리의 코드는 이전보다 복잡하고 다양한 상태를 관리하게 되었습니다. 상태라 하면, 서버에서 받은 정보일수도 있고, 캐쉬된 데이터일수도 있고, 사용자가 입력중인 데이터일 수도 있고, 혹은 아직 서버쪽에 전송되지 않은 데이터일수도 있습니다. 이런 어플리케이션의 상태에 따라 프론트엔드에서 보여주고 관리해야하는 UI 상태 또한 매우 복잡해졌습니다.

연속적으로 끊임없이 변하는 상태를 관리하는 것은 굉장히 어려운 일입니다. 만약 어떤 모듈이 다른 모듈의 데이터를 업데이트시키고, 또 다른 모듈이 또 다른 모듈의 데이터를 업데이트시키고, 그리고 또 다시 다른 모듈이 업데이트되어야하고, 이런 일련의 과정 속에서 작업을 하다보면 우리는 도대체 어플리케이션의 상태가 언제 어디서 어떻게 변화했는지 추적하는 과정에서 큰 혼란이 올 수 있습니다.

> 리덕스라는 패턴은 이런 일련의 혼란스러운 과정속에 묻혀있는 어플리케이션의 상태 관리를 조금 더 단순하고 **예측 가능하게** 다루기 위해서 시작된 것입니다.

<br />
<br />

## 리덕스는 언제 사용해야 할까?

<br />

**"The need to use Redux should not be taken for granted."**

> "Redux의 사용을 당연시 여겨서는 안됩니다."

**As Pete Hunt, one of the early contributors to React, says:**

> React 초기 개발을 이끌었던 Pete Hunt가 말했듯이:

<br />
<Alert
  showIcon
  message="Pete Hunt는 리액트 팀의 초기 리드 개발자로서, 인스타그램 프론트엔드 팀의 리드 개발자이기도 했습니다."
  type="info"
/>

**"You'll know when you need Flux. If you aren't sure if you need it, you don't need it."**

> "당신이 Flux가 필요할때가 오면 스스로 알게 될 것이다. 만약 필요성에 대해 확신이 서지 않는다면, 당신은 Flux가 필요하지 않은 것이다."

<br />
<Alert
  showIcon
  message="Flux란 페이스북에서 만든 Redux의 조상과 같은 라이브러리입니다."
  type="info"
/>

**Similarly, Dan Abramov, one of the creators of Redux, says:**

> Redux를 만든 Dan Abramov 또한 유사한 발언을 했습니다:

**"I would like to amend this: don't use Redux until you have problems with vanilla React."**

> "이 말을 더하고 싶습니다: Redux없이 React만으로 개발을 하는 것이 문제를 발생시키는 시점까지 Redux를 사용하지 마세요."

<br />
<br />

## 리덕스는 누가 만들었나?

![Dan Abramov](./assets/intro-to-redux/dan.jpeg)
_Dan Abramov_

- [Twitter](https://twitter.com/dan_abramov)
- [Github](https://github.com/gaearon)
- [Blog - Overreacted.io](https://overreacted.io)

Redux는 Dan Abramov라는 개발자가 [React Europe](https://www.react-europe.org)이라는 컨퍼런스 발표를 위해 준비하는 과정에서 만들어졌습니다. Dan Abramov는 Redux를 만들어 명성을 얻었고 현재 Facebook에서 React 개발을 이끌고 있습니다.

<br />
<Alert
  showIcon
  message="React Europe은 매년 5월 프랑스 파리에서 개최되는 세계 최대 규모의 React 컨퍼런스입니다."
  type="info"
/>

<br />
<br />

## 리덕스의 목적

리액트에서 복잡한 상태를 다루다 보면, 많은 컴포넌트가 상태를 공유하게 되고, 상태 공유를 위해 우리는 상태 끌어올리기를 시도하게 됩니다. 어플리케이션이 복잡해지면 복잡해질수록, 끌어올려지는 상태는 많아질 수 밖에 없으며 궁극적으로는 컴포넌트 트리에서 위쪽에 자리잡은 컴포넌트들이 대부분의 상태를 관리하게 되는 형국을 맞이하게 됩니다.

컴포넌트 트리에서 상태 위치의 불균형이 발생하며, 상태 관리에 대한 복잡도가 특정 컴포넌트에게 집중되게 됩니다. 이것은 해당 컴포넌트들에게 부담으로 다가갈 수 밖에 없으며, 개발자 입장에서도 상태 변화에 대한 추적이 어렵고 개발이 난해한 상황이 발생합니다.

이런 상황에서 어플리케이션의 전체적인 상태 관리를 위한 전문적인 솔루션으로 등장하는 것이 바로, 리덕스입니다.

<br />
<br />

## 리덕스의 데이터 흐름

<br />

### 1. Action

Action이란, **우리 어플리케이션 상태에 영향을 미치는 사건**을 표현/묘사하는 객체입니다. 어떤 정보가 서버로부터 성공적으로 돌아왔다는 정보를 묘사할 수도 있고, 어플리케이션에서 발생한 에러에 대한 정보를 묘사할 수도 있습니다. 하지만 항상 하나의 Action은 **단일 사건**에 대해서만 묘사해야 합니다.

Redux에서 Action이란 아래와 같이 단순 Javascript Object로 표현합니다.

<br />
<Alert
  showIcon
  message="Action 객체에는 항상 `type`이라는 속성이 있습니다. Action에 대한 제목이라고 생각하시면 됩니다."
  type="info"
/>
<br />

아래 예시는 Todo List를 정렬하는 사건이 발생했다는 것을 나타내는 액션입니다.

```jsx
{
  "type": "SORT_TODO_LIST_BY_ASCENDING_DATE"
}
```

<br />

아래 예시는 새로운 Todo를 추가하는 사건이 발생했다는 것을 나타내는 액션입니다.

```jsx
{
  "type": "NEW_TODO",
  "text": "Eat Food"
}
```

<br />

아래 예시는 어떤 의미의 액션이며, 각 데이터 필드는 왜 존재하는 것일까요?

```jsx
{
  "type": "UPDATE_TODO",
  "todo": {
    "id": 1,
    "text": "Don't Eat Food",
    "completed": false
  }
}
```

<br />
<br />

#### 그렇다면 액션을 발생시키기 위해서는 구체적으로 어떻게 해야할까요?

리덕스에는 `dispatch`라는 메소드가 제공됩니다. 우리는 `dispatch` 메소드를 이용하여 액션을 발생시킬 수 있습니다.

리덕스의 목적은 단 하나, 상태를 잘 관리하는 것입니다. 리덕스가 관리하고 있는 상태 정보가 수정되어야 한다면, 우리는 액션을 `dispatch`시키고, 리덕스에게 상태 수정이 되어야 한다는 시작 신호를 주어야 하는 것입니다.

> 우선 지금은 개념적으로 액션이라는 존재에 대해 이해하도록 하세요. 다음 페이지에서 구체적인 예시를 보여드리도록 하겠습니다.

<br />
<br />

### 2. 리듀서

액션이 발생하게 되면, 우리는 리듀서라는 함수에서 상태 변화에 대한 연산을 진행합니다.

리듀서라는 단어는 `Array.prototype.reduce`에서 인자로 넘겨주는 리듀서 함수의 의미와 동일합니다. 단순히 함수일 뿐이며 순수 함수입니다. 리덕스에서는 리듀서가 핵심적인 역할을 하여 사용된다는 사실은 곧 리덕스에 함수형 컨셉이 깊게 스며들어 있다는 의미입니다. 그래서 우리는 더욱 **"예측 가능한"** 코드를 작성할 수 있습니다.

`Array.prototype.reduce`의 리듀서 함수는 아래와 같이 4가지 매개변수를 받습니다.

- Accumulator (누적값)
- Current Value (현재 요소)
- Current Index (현재 요소의 인덱스)
- Source Array (출처 배열)

우리는 리듀서 함수 내에서 Accumulator(누적값)과 Current Value(현재 요소)를 이용하여 새로운 값을 반환합니다. 그리고 그 값이 우리의 새로운 Accumulator(누적값)이 됩니다.

**리덕스에서 사용되는 리듀서 또한 이와 유사하게 매개변수를 받습니다.**

- Accumulated State (누적된 State)
- Current Action (현재 Action)

우리는 리듀서 함수 내에서 Accumulated State(누적된 State)와 Current Action(현재 Action)을 이용하여 새로운 값을 반환합니다. 우리가 연산하여 반환해주는 값이 새로운 Accumulated State(누적된 State)가 됩니다.

우리가 해야 할 일은 리듀서내에서 현재 발생한 액션의 내용에 따라 상태가 어떤 식으로 변형되어야 하는지 연산하고 반환해주는 일입니다.

**리덕스는 하나의 새로운 액션이 발생할때마다 리듀서 함수를 실행시킵니다.** 액션이 5번 발생한다면 리듀서는 5번 실행됩니다. 리듀서 함수의 실행 여부는 우리의 책임 소재가 아닙니다. 리덕스가 자체적으로 관리하고 액션이 발생할때마다 적절한 인수와 함께 실행시켜주도록 설계되어 있습니다.

```jsx
function visibilityFilterReducer(state = "SHOW_ALL", action) {
  if (action.type === "SET_VISIBILITY_FILTER") {
    return action.filter;
  } else {
    return state;
  }
}
```

<br />
<br />

**리듀서 내에서 우리가 새로운 상태 값을 반환하게되면, 리덕스는 해당 반환값을 이용해서 무엇을 할까요?**

<br />
<br />

### 3. 스토어

리듀서에서 반환한 새로운 상태는 스토어(Store)라는 곳에 반영되고 저장됩니다. 스토어란, 리덕스가 어플리케이션의 상태를 보관하는 곳입니다. 모든 상태는 하나의 스토어에서 관리되고 수정됩니다. 단일한 스토어를 이용하여 리덕스는 동작하며, 이 덕분에 우리는 **Single Source of Truth**라는 장점을 얻을 수 있습니다.

이처럼 스토어 내의 상태가 성공적으로 수정되면, 스토어는 관련있는 모듈에게 새로운 상태 정보를 전달합니다.

<br />
<Alert
  showIcon
  message="스토어를 우리가 직접적으로 관리하는 일은 없습니다. 리덕스가 내부적으로 관리하는 데이터 저장소입니다."
  type="info"
/>

<br />
<br />

## 리덕스 데이터 흐름 요약

<br />

리덕스의 데이터 흐름을 다시 한번 돌아보자면 아래와 같습니다.

1. 액션(Action) 발생

2. 리듀셔(Reducer) 함수 실행: 누적된 상태(State)와 액션(Action) 정보를 이용하여 새로운 상태(State) 반환

3. 새로운 상태(State) 데이터를 스토어(Store)에 반영

4. (다음 페이지에서 예시) 새로운 상태(State) 정보와 함께 컴포넌트 re-rendering

<br />
<br />

## 리덕스 글로벌 상태와 로컬 상태

<br />

리덕스를 사용하더라도 기본적으로 아래 두 가지 경우에 대해서는 로컬 상태를 사용합니다.

1. 다른 컴포넌트와 공유하지 않아도 되는 상태
2. 상태를 소유한 컴포넌트가 Unmount 되는 시점 이후, 더 이상 보관할 필요가 없는 상태

상황에 따라 약간의 차이점은 있을 수 있지만, **위 두가지 케이스를 제외한 모든 상태는 전부 다 리덕스 글로벌 상태로 관리하는 것이 일반적입니다.**

<br />
<br />

## 참고자료

<br />

📖 [다양한 Redux 샘플 프로젝트](https://github.com/reduxjs/redux/tree/master/examples)

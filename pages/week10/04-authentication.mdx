import { Alert } from "antd";
import { Callout } from "nextra-theme-docs";

# 사용자 인증

사용자 인증 기능은 어떤 어플리케이션에서든 자주 사용되고 개발자라면 누구나 반드시 알고 있어야 할 기초 교양과 같은 항목입니다. 사용자 인증은 크게 나누어, 세션 방식과 토큰 방식으로 나뉘어 구현할 수 있습니다. 사용자 인증의 두 가지 방식과 함께 이와 관련해서 자주 등장하는 개념들에 대해 알아보도록 하겠습니다.

<br />
<br />

## 사용자를 기억하는 목적

<br />

사용자 인증의 목적에 대한 이야기부터 해보겠습니다. HTTP 프로토콜에는 2가지 특징이 존재합니다.

1. 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊는다 (connectionless)
2. 클라이언트와 서버의 통신이 끝나면 상태를 유지하지 않는다 (stateless)

위 2가지 특성으로 인해 서버는 클라이언트와 연결이 끊어지게 되면 클라이언트의 이전 상태를 기억하지 못하게 되고, 클라이언트가 과거에 로그인을 성공하더라도 로그인 정보를 유지할 수가 없게 됩니다.

하지만 현실세계에서는 브라우저에 접속하고 있는 현재 사용자를 인지하고 있어야 하는 경우가 더 많습니다. 쇼핑몰에서 로그인 한 후 옷을 장바구니에 보관했는데 매번 페이지를 이동할 때 마다 새롭게 인증을 해야한다면 사용률이 현저히 떨어지겠죠? 이런 특성을 보완하려면 **웹 통신간 정보가 유지**되어야 하고, **정보를 유지하기 위해서는 어떤 방식으로든 사용자 인증이 필요**합니다.

<br />
<br />

## 세션 기반의 사용자 인증

<br />

![session](./assets/auth/session.jpeg)

<br />

### 세션 인증 흐름

1. 브라우저에 접속한 사용자가 사용자 인증 정보를 서버로 보냅니다. 예) 이메일 + 비밀번호
2. 서버는 해당 사용자가 존재하는지 확인한 후, 세션 정보를 생성하여 데이터베이스나 서버 메모리에 저장합니다.
3. 서버는 생성한 세션 정보의 ID값을 쿠키에 포함하여 브라우저로 전달합니다. (일반적으로 세션 ID만을 저장하지만, 상황에 따라 저장하는 정보가 다를 수 있습니다.)
4. 쿠키를 전달받은 브라우저는 앞으로 같은 도메인에 접속하여 요청을 보낼 경우, Header에 쿠키를 포함하게 됩니다.
5. 인증 권한이 필요한 다른 요청을 서버로 보냅니다. (쿠키는 자동으로 Header에 포함됩니다.)
6. 서버는 쿠키에 저장된 세션 ID를 이용하여 사용자에 대한 인증 정보를 검증합니다.
7. 검증이 통과될 경우, 요청에 대한 정상적인 처리를 진행하고 응답을 보냅니다.
8. 검증이 실패할 겨우, 요청에 대한 오류 처리를 진행하고 응답을 보냅니다.

<br />

### 쿠키

쿠키란 클라이언트(브라우저)에 `key`와 `value`값이 들어있는(이름, 값) 작은 데이터 파일입니다. 브라우저의 개발자 도구를 이용하여 쿠키를 직접 확인할 수 있습니다.

![cookie](./assets/auth/cookie.png)

#### 쿠키의 특징

- 쿠키는 주로 서버에 의해 만들어 집니다. 서버가 HTTP 응답 헤더(header)의 `Set-Cookie` 에 내용을 넣어 전달하면, 브라우저는 이 내용을 자체적으로 브라우저에 저장합니다.
- 쿠키란 각 도메인에 따라 별개로 취급되고 사용됩니다. 구글의 쿠키와 트위터의 쿠키는 완전 별개로 취급되며 서로 접근이 불가합니다.
- 현재 사용자가 접속한 도메인에 대한 쿠키가 브라우저에 존재한다면, 브라우저는 서버로 요청을 보낼때마다 모든 요청에 해당 쿠키를 자동으로 요청 헤더(header)에 포함 시키도록 되어있습니다.
- 브라우저마다 쿠키를 저장할 수 있는 용량에 대한 차이가 있으며, 전반적인 용량제한은 매우 작습니다. 그렇기에 작은 양의 데이터만 보관 가능합니다.
- 쿠키와 로컬 스토리지, 세션 스토리지 등은 모두 브라우저에 존재하는 저장 공간이며 용도와 기능이 다릅니다.

<br />

개발자 도구 콘솔창에 아래 코드를 실행하여 현재 브라우저에 저장된 쿠키를 확인해볼 수 있습니다.

```js
console.log(document.cookie); // cookie1=value1; cookie2=value2;...
```

![cookie console](./assets/auth/cookie_console.png)

<br />

세션 기반의 사용자 인증은 보통 쿠키에 대한 의존을 필수적으로 하지만, 사용자 정보 파일을 클라이언트(브라우저)에 저장하는 쿠키와 달리 세션은 **서버 측에서 관리**되는 데이터입니다. 사용자가 인증에 성공하게 되면, 서버는 사용자 정보를 바탕으로 데이터베이스에 사용자 인증 정보를 생성하게 됩니다. 이 사용자 정보가 저장된 세션 ID를 클라이언트의 쿠키로 저장하게 됩니다. 이후 모든 후속 요청 시 쿠키에 있는 세션 ID를 통해 서버는 데이터베이스에서 사용자의 정보를 조회해야 합니다. 여기서 단순히 쿠키는 세션 ID를 전달하는 매개체일 뿐입니다.

이처럼 사용자가 우리 어플리케이션에 인증을 통과하게 되면, 우리는 인증에 성공한 사용자에 대한 정보를 받게 됩니다. 그리고 우리는 쿠키로 들어온 세션 ID를 이용하여 데이터베이스나 서버 메모리 상에 특정 사용자에 관한 내용을 관리할 수 있습니다. 접속한 사용자에 대한 정보를 기반으로 생성되는 **추상적인 과정과 개념을 세션**이라고 합니다.

세션은 클라이언트의 상태를 추적함에 있어 DB에 의존하고 있고, 이는 모든 요청마다 데이터베이스를 조회해야 한다는 말입니다. 또 인증에 성공한 사용자가 여러 명이라면, 추적을 하기 위해선 모든 세션 ID를 세션 데이터베이스에 저장해야 합니다. 즉 사용자가 증가할수록 서버에 필요한 리소스가 더 많아지게 됩니다. 이런 단점을 보완한 방식이 바로 토큰 방식입니다.

<br />
<br />

### 장점

- 클라이언트에 노출되지 않고 서버에서 사용자 인증을 관리하기 때문에, Cross Site Scripting (XSS) 공격으로부터 안전합니다.

<br />

### 단점

- 서버에서 관리해야 할 내용이 생기는 것이므로, 서비스의 스케일이 커질수록 관리가 어려워집니다.
- Stateless하지 않습니다.
- 쿠키는 브라우저를 위해 만들어진 개념이기 때문에 브라우저가 아닌 환경에서 쿠키는 제약이 생기게 되므로 모바일 기기에 대한 지원이 어렵습니다.
- 서버와 다른 도메인의 클라이언트를 지원한다면 CORS 문제에 대한 해결책을 마련해야 합니다.
- Cross-Site Request Forgery (XSRF or CSRF) 공격에 취약합니다.

<br />

> CORS(Cross Origin Resource Sharing)란 무엇일까요?

<br />
<br />

## 토큰 기반의 사용자 인증

<br />

토큰 기반의 사용자 인증은 JSONWebToken(JWT) 등과 쿠키, 로컬 스토리지 등의 브라우저 저장공간을 활용한 사용자 인증 방식입니다. 이 방식은 상대적으로 최근에 더욱 많이 활용되고 있습니다. 그렇지만, 세션이나 토큰 그 어떤 것이 더 좋은 방식이라기보다는 각각의 장단점을 알고 상황에 따라 적절히 사용할 수 있는 능력을 키우는 것이 중요합니다.

<br />

### JSONWebToken(JWT)이란?

![jwt](./assets/auth/JWT.png)

JWT란, JSON 자료를 Encoding한 형태의 토큰을 의미합니다. **Header, Payload, Signature 세 가지 파트**로 이루어져 있으며 각 부분은 `.`을 이용하여 구분됩니다.

- 헤더(Header): 토큰 종류와 해시 알고리즘 정보가 들어 있습니다.
- 페이로드(Payload): 토큰의 내용물이 인코딩된 부분입니다.
- 시그니처(Signature): 일련의 문자열로, 시그니처를 통해 토큰이 변조되었는지 여부를 확인할 수 있습니다.

중요한 점은 JWT는 기본적으로 Encryption(암호화)를 제공하는 것이 아니라, Encoding를 제공하는 토큰이라는 것입니다. 누구나 어렵지 않게 Decode할 수 있기 때문에 중요한 정보는 보관하지 않는 것이 좋습니다.

로그인 요청 시 올바른 정보를 기입하였다면 서버에서는 로그인 정보를 이용하여 JWT 토큰을 생성합니다. 클라이언트는 매 요청마다 헤더에 JWT를 전달하여 인증을 확인하고 서버에서는 JWT를 확인하는 과정만 거친 후 정보를 보내면 됩니다. 세션과 같은 방식처럼 서버에서 별도로 세션 ID를 저장해두거나, 세션 데이터베이스를 관리할 필요도 없습니다. 사용자 인증 절차에 있어 서버의 부담이 훨씬 줄어들게 됩니다. 

<br />

### 토큰 인증 흐름

![token](./assets/auth/token.jpeg)

1. 클라이언트에서 서버로 사용자 정보와 함께 로그인 요청을 보냅니다.
2. 서버에서는 사용자 정보를 검증하고, 토큰을 발급합니다.
3. 클라이언트는 토큰을 쿠키, 로컬 스토리지 등에 보관하고 사용자 인증이 필요한 후속 요청을 보낼때 토큰을 함께 보냅니다.
4. 서버에서는 토큰을 이용하여 사용자를 검증하고 요청에 대한 처리를 진행합니다.

<br />

### 장점

- 서버측의 작업이 Stateless합니다.
- 클라이언트가 토큰을 관리하게 되므로, 서버의 스케일링이 더욱 쉽습니다.
- JWT를 이용한 인증 방식이기 때문에 Cross Domain 이슈와 관계없이 검증을 할 수 있습니다.
- 브라우저 이외의 클라이어트 기기(모바일 앱, 데스크탑 실행 프로그램 등)에 대한 지원이 더욱 쉽습니다.
- Cross-Site Request Forgery (XSRF or CSRF) 공격으로부터 안전합니다.

<br />

### 단점

- 토큰을 도난당할 경우, 막을 수 없습니다. 그래서 일반적으로 토큰 유효 기간을 아주 짧게 설정하고 리프레쉬 토큰이라는 기술을 추가적으로 도입하여 활용합니다.
- Cross Site Scripting (XSS)에 대한 위험이 있습니다. 하지만 대중적으로 사용되는 많은 라이브러리들은 이에 대한 기초적인 수준의 보안 기능이 있습니다.

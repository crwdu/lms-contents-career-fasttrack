# 5. Data Flow in React

## Understanding the problem

아래와 같이 두 개의 함수가 있습니다. 1번 함수(`processOne`)에서 연산된 값을 2번 함수(`processTwo`)에서 필요로 하고 있습니다. 어떻게 공유할 수 있을까요?

```jsx
function init() {
  function processOne() {
    const a = 1;
    const b = 2;

    // Want to share `result` value with `processTwo` function
    const result = a * b * 3;
  }

  function processTwo() {
    // Want to access `result` 🧐
    const finalResult = result * 2;
  }

  processOne();
  processTwo();
}
```

우선 가장 간단한 방법은 `result` 변수의 선언위치를 상위 스코프로 옮기는 것입니다. 상위 스코프에 있는 값은 `processTwo` 함수에서도 접근 가능하기 때문에, 우리가 당면했던 문제를 해결할 수 있습니다.

```jsx
function init() {
  let result = null;

  function processOne() {
    const a = 1;
    const b = 2;

    result = a * b * 3;
  }

  function processTwo() {
    // We can access `result`..!! :)
    const finalResult = result * 2;
  }

  processOne();
  processTwo();
}
```

## Data flow in React Applications

위와 비슷한 상황을 리액트에서 살펴보겠습니다.

```jsx
function App() {
  return (
    <>
      <Header />
      <SignupForm />
    </>
  );
}

function Header() {
  return (
    <header>
      <p>Current user is: {/* username */}</p>
    </header>
  );
}

function SignupForm() {
  const [username, setUsername] = useState("");

  function handleSubmit(ev) {
    ev.preventDefault();
    alert(`이름: ${username}`);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input value={username} onChange={(ev) => setUsername(ev.target.value)} />
    </form>
  );
}
```

위 예제에서 `Header` 컴포넌트는 `SignupForm` 컴포넌트 내부에서 연산되는 사용자 이름을 필요로 하고 있습니다. 하지만 `Header` 컴포넌트에서 `username` 값에 접근할 수 있는 방법이 없습니다.

`App` 컴포넌트에 새로운 상태를 선언해주고 두 가지 하위 컴포넌트에서 공용으로 사용하도록 재구성해보겠습니다.

```jsx
function App() {
  const [username, setUsername] = useState("");

  return (
    <>
      <Header username={username} />
      <SignupForm onSubmit={(value) => setUsername(value)} />
    </>
  );
}

function Header({ username }) {
  return (
    <header>
      <p>Current user is: {username}</p>
    </header>
  );
}

function SignupForm({ onSubmit }) {
  // 이 상태는 무엇을 위한 상태일까요?
  // 왜 이 상태를 App으로 옮기지 않고, App에 새로운 상태를 선언한 것일까요?
  const [username, setUsername] = useState("");

  function handleSubmit(ev) {
    ev.preventDefault();
    onSubmit(username);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input value={username} onChange={(ev) => setUsername(ev.target.value)} />
    </form>
  );
}
```

## Conclusion

위에서 시도한 방법은 많은 상황에 적용될 수 있습니다. 컴포넌트 트리 구조 내에서 Sibling 관계나 그와 유사한 관계에 있는 컴포넌트 간에 데이터를 공유해야 할 경우, 위와 같은 방법으로 해결할 수 있습니다.

**📖 _State 끌어올리기_**

[State 끌어올리기 - React](https://ko.reactjs.org/docs/lifting-state-up.html)

**📖 _교훈_**

> React 애플리케이션 안에서 변경이 일어나는 데이터에 대해서는 “**진리의 원천(source of truth)“**을 하나만 두어야 합니다. 보통의 경우, state는 렌더링에 그 값을 필요로 하는 컴포넌트에 먼저 추가됩니다. 그러고 나서 다른 컴포넌트도 역시 그 값이 필요하게 되면 그 값을 그들의 **가장 가까운 공통 조상**으로 끌어올리면 됩니다. 다른 컴포넌트 간에 존재하는 state를 동기화시키려고 노력하는 대신 **하향식 데이터 흐름**에 기대는 걸 추천합니다.

[State 끌어올리기 - React](https://ko.reactjs.org/docs/lifting-state-up.html#lessons-learned)

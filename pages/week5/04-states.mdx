import { Callout } from "nextra-theme-docs";

# 상태

컴포넌트에 대해 더 깊이 이해하기 위해서는 함수에 대한 이해가 우선되어야 합니다. 함수에 대해 다시 한번 생각해봅시다.

```jsx showLineNumbers
// size 메소드 외의 기능에 대한 자세한 코드는 생략합니다.
class LinkedList {
  add(value) {
    let newNode = new Node(value);

    if (!this.head) {
      this.head = newNode;
      return this.head;
    }

    let tail = this.head;

    while (tail.next !== null) {
      tail = tail.next;
    }

    tail.next = newNode;

    return this.head;
  }

  size() {
    let count = 0;
    let node = this.head;

    while (node) {
      count++;
      node = node.next;
    }

    return count;
  }
}

const PEOPLE = ["Huh", "Kim", "Hwang", "Jung", "Min"];
const linkedList = new LinkedList();

PEOPLE.forEach((person) => linkedList.add(person));

const result = linkedList.size();
console.log(result);
```

<br/>
<br/>

## 지역 변수

지역 변수란 무엇이고, 어떤 경우에 사용하나요? 위 예제에서 구현된 `size` 함수를 살펴보세요.

`node` 라는 변수를 만들어 사용하고 있습니다. 함수 연산과정에서 `node` 변수에 임시적으로 값을 저장하고 지속적으로 수정하며, 함수 로직의 상태를 관리하고 있습니다.

<br/>
<br/>

## 상태

_리액트의 상태는 함수에서의 지역변수와 동일한 개념입니다._

상황에 따라 가변적인 정보와 UI가 연관될 수 있습니다. 이런 가변적인 정보를 상태라 부르고, 이 상태를 관리할 수 있는 방법이 바로 상태(`state`) 입니다.

<br/>
<br/>

### 상태의 조건

1. 가변적인 데이터
2. UI 렌더링과 연관된 데이터

이 두가지를 모두 충족해야 "상태"라고 할 수 있습니다. 둘 중 하나라도 충족하지 않는다면, 그것은 상태가 아닙니다.

<br/>
<br/>

아래와 같은 컴포넌트가 있다고 생각해보세요.

```jsx showLineNumbers
export default function ShoppingItem(props) {
  const { name, price } = props.item;

  return (
    <div>
      <h3>{name}</h3>
      <h4>{price}원</h4>
      <div>
        <div>-</div>
        <div>1</div>
        <div>+</div>
      </div>
    </div>
  );
}
```

사용자가 더하기, 빼기 버튼을 클릭할때마다 우리는 수량의 값을 변경시켜 UI에 반영하고 싶습니다. 이와 같은 상황에서 우리는 상태를 이용하여 가변적인 수량을 관리할 수 있습니다. 상태를 생성할때 사용되는 `useState` 함수를 이용하여 수량 관리를 적용시켜 보겠습니다.

<br/>
<br/>

### 📘 공식문서

- [상태 - 컴포넌트의 메모리](https://react-ko.dev/learn/state-a-components-memory)

<br/>
<br/>

### 상태와 Props는 어떻게 다른 것인가?

Props는 외부에서 컴포넌트에게 전달되어 주어지는 데이터고, 상태는 컴포넌트 내부에서 생성되어 관리되는 가변적인 데이터입니다.

> [props vs state](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)

```jsx
export default function ShoppingItem(props) {
  const { name, price } = props.item;
  const [quantity, setQuantity] = useState(1);

  return (
    <div>
      <h3>{name}</h3>
      <h4>{price}원</h4>
      <div>
        <div>-</div>
        <div>{quantity}</div>
        <div>+</div>
      </div>
    </div>
  );
}
```

위 예제에 사용자가 더하기, 빼기 버튼을 클릭할때마다 해당 수량을 변경하는 코드를 추가해보면 아래와 같습니다.

```jsx
export default function ShoppingItem(props) {
  const { name, price } = props.item;
  const [quantity, setQuantity] = useState(1);

  function changeQuantity(qty) {
    setQuantity(quantity + qty);
  }

  return (
    <div>
      <h3>{name}</h3>
      <h4>{price}원</h4>
      <div>
        <div onClick={() => changeQuantity(-1)}>-</div>
        <div>{quantity}</div>
        <div onClick={() => changeQuantity(1)}>+</div>
      </div>
    </div>
  );
}
```

**🖥 _Example Link_**

[react-states](https://codesandbox.io/s/react-states-0imyk)

**📖 _useState_**

[Hooks API Reference - React](https://ko.reactjs.org/docs/hooks-reference.html#usestate)

수량을 조절하는 로직은 우리가 원하는대로 구성할 수 있습니다. 만약 0 이하의 수량은 허용하지 않고 싶다면 아래와 같이 작성할 수 있습니다.

```jsx
export default function ShoppingItem(props) {
  const { name, price } = props.item;
  const [quantity, setQuantity] = useState(1);

  function changeQuantity(qty) {
    const quantitySum = quantity + qty;

    if (quantitySum < 0) return;

    setQuantity(quantitySum);
  }

  return (
    <div>
      <h3>{name}</h3>
      <h4>{price}원</h4>
      <div>
        <div onClick={() => changeQuantity(-1)}>-</div>
        <div>{quantity}</div>
        <div onClick={() => changeQuantity(1)}>+</div>
      </div>
    </div>
  );
}
```

우리는 우리가 원하는 만큼 다양한 `state` 값을 만들어 사용할 수 있습니다. 아래 코드에서는 && 연산자를 이용하여 조건에 따라 보여주거나 숨겨주는 로직을 작성했습니다.

<aside>
📌 상태(State)는 반드시 UI에 보여지는 내용과 연관된 데이터이어야 합니다.

</aside>

```jsx
export default function ShoppingItem(props) {
  const { name, price } = props.item;
  const [quantity, setQuantity] = useState(1);
  const [error, setError] = useState("");

  function changeQuantity(qty) {
    if (quantity <= 0 && qty === -1) {
      setError("수량은 0 이상이어야 합니다.");
      return;
    }

    setQuantity(quantity + qty);
  }

  return (
    <div>
      {error && <p>{error}</p>}
      <h3>{name}</h3>
      <h4>{price}원</h4>
      <div>
        <div onClick={() => changeQuantity(-1)}>-</div>
        <div>{quantity}</div>
        <div onClick={() => changeQuantity(1)}>+</div>
      </div>
    </div>
  );
}
```

**📖 _Conditional Rendering_**

[조건부 렌더링 - React](https://ko.reactjs.org/docs/conditional-rendering.html)

## ⚡️ setState 호출은 비동기로 동작합니다.

_Calls to setState are asynchronous_

[async-setState](https://codesandbox.io/s/async-setstate-yr9y2)

[컴포넌트 State - React](https://ko.reactjs.org/docs/faq-state.html#why-is-setstate-giving-me-the-wrong-value)

## ▶︎ 상태 변화에 대해 React는 어떻게 대응할까요?

**_React re-renders the whole app on every update._**

_The key design decision that makes React awesome._

_When the data changes, React re-renders the entire component._

_That is, React components are basically just **idempotent functions**._

_They describe your UI at any point in time._

"_Updating the whole app" when state changes seems **expensive** (not effective)?_

# Virtual DOM

### Goal

_Makes re-rendering on every change **fast**._

### What if we throw out the DOM and rebuild it on every update?

_It's too slow and you will lose form state and scroll position._

### So React team built a **virtual DOM** and **events system**.

_Optimized for performance and memory footprint._

### On every update,

1. _React builds a new virtual DOM subtree._
2. _Compare it with the old virtual DOM subtree._
3. _Computes the minimal set of DOM mutations and puts them in a queue._
4. _Batch executes all updates. → UI updates on browser._

### Reconciliation

[재조정 (Reconciliation) - React](https://ko.reactjs.org/docs/reconciliation.html)

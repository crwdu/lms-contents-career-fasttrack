import { Sandpack } from "@codesandbox/sandpack-react";
import { githubLight } from "@codesandbox/sandpack-themes";
import { Callout } from "nextra-theme-docs";

# 리액트 소개

_A library for creating **User Interfaces**._

_Renders your UI and responds to events._

_The **V** in **MVC**._

<br />

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/x7cQ3mrcKaY?start=1"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowFullScreen
></iframe>

<br />
<br />

## 리액트 맛보기

아래와 같이 간단하게 우리는 React를 시작할 수 있습니다.

<br />

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/index.js": {
      code: `import React from "react";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));

root.render(<h1>안녕하세요</h1>);`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "200px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

위의 예시에서 HTML과 유사하게 생긴 코드는 HTML이 아닙니다. JSX라고 부르는 문법입니다.

<br />
<br />

## JSX란

> _JSX is an **optional preprocessor** to let you use HTML-like syntax._

JSX는 HTML처럼 생긴 문법을 사용 가능하게 해주는 전처리 장치입니다. JSX는 HTML과 같은 문법을 사용 가능하게 해주며, 자바스크립트를 함께 사용할 수 있도록 합니다.

<br />
<br />

### 📘 공식문서

- [JSX로 마크업 작성하기](https://react-ko.dev/learn/writing-markup-with-jsx)
- [JSX에서 자바스크립트 사용하기](https://react-ko.dev/learn/javascript-in-jsx-with-curly-braces)

<br />
<br />

## 트랜스파일

JSX는 (대략) 아래와 같은 순수 자바스크립트로 변환되어 브라우저에서 실행됩니다. 이런 변환 과정을 트랜스파일이라고 부릅니다.

```js showLineNumbers {1}
import React from "react";
import { createRoot } from "react-dom/client";

const element = React.createElement("div", null, "자, 여러분..");
const root = createRoot(document.getElementById("root"));

root.render(element);
```

- `React.createElement` 함수의 첫 번째 인자는 DOM Element Type을 나타냅니다.
- 두 번째 인자는 Attribute를 나타냅니다. (React에서는 Element의 Attribute를 **Props**라고 부릅니다.)
- 나머지 인자는 Child Element입니다.

위에서 언급된 `React.createElement`에 대해서는 자세히 살펴볼 필요는 없습니다. 여러분은 대부분 JSX를 이용해 React를 사용하게 될 것입니다. 하지만 원리를 알고 사용하는 것이 좋기에 내부적으로 어떤 과정을 거쳐 브라우저에서 실행되는지 설명드리는것 뿐입니다.

<br/>
<br/>

Child Element란, 단순 텍스트가 될 수도 있지만 또 다른 React Element가 될 수도 있습니다. 그리고 또한 여러 개의 Child를 가질 수도 있습니다.

```jsx showLineNumbers {2-7}
import React from "react";
import { createRoot } from "react-dom/client";

const text = "I am a paragraph";
const element = React.createElement(
  "div",
  { className: "something" },
  "hello",
  React.createElement("p", { style: { fontSize: "30px" } }, text)
);

const root = createRoot(document.getElementById("root"));

root.render(element);
```

모든 것은 Javascript입니다. 그렇기에 우리는 변수(`text`)를 사용할 수도 있습니다.

<br/>
<br/>

위의 코드를 JSX로 바꿔서 작성해보겠습니다. 몇가지 이해가지 않는 부분이 있겠지만, 위의 코드와 아래 코드를 비교했을때 어떤 차이가 느껴지시나요? 어느 쪽이 더 읽기 편하신가요?

```jsx showLineNumbers {2-6}
import React from "react";
import { createRoot } from "react-dom/client";

const text = "I am a paragraph";
const element = (
  <div className="something">
    hello<p style={{ fontSize: "30px" }}>{text}</p>
  </div>
);

const root = createRoot(document.getElementById("root"));

root.render(element);
```

<br />
<br />

### 📘 공식문서

- [JSX 없이 사용하는 React](https://ko.reactjs.org/docs/react-without-jsx.html)

<br />
<br />

위에 공유드린 ["JSX에서 자바스크립트 사용하기"](https://react-ko.dev/learn/javascript-in-jsx-with-curly-braces) 리액트 문서에서 보셨겠지만, JSX에서 우리는 `{}` (중괄호) 를 이용하여 `{}` (중괄호) 내부에 Javascript Expression을 삽입할 수 있습니다. 위 예제에서 보이는 `{text}` 와 같이 말입니다.

> Javascript Expression이란, 어떤 특정 값으로 귀결되는 코드 단락을 의미합니다.

<br />
<br />

## 컴포넌트

<br />

> _Use **components** to separate your concerns._

관심사를 분리하기 위해 컴포넌트를 사용해야 합니다.

> _Components are **composable**._

컴포넌트는 조합이 가능합니다.

> _Components are **unit testable**._

컴포넌트는 단위 테스트가 용이합니다.

> _Only put **display logic** in your components._

컴포넌트는 화면을 그리는 로직만 담도록 해야 합니다.

> _No explicit DOM operations. **Declarative**._

컴포넌트는 직접적인 DOM 조작을 하지 않아야 합니다. 선언적으로 작업해야 합니다.

<br />
<br />

##### 일반 변수를 활용한 예시

```jsx showLineNumbers
import React from "react";
import { createRoot } from "react-dom/client";

const text = "I am a paragraph";
const someText = <p>I am something else.</p>;

const element = (
  <div className="something">
    {someText}
    <p style={{ fontSize: "30px" }}>{text}</p>
  </div>
);

const root = createRoot(document.getElementById("root"));

root.render(element);
```

위 예제에서 `someText`와 `element`는 현재 React Element를 담고 있는 일반 변수입니다. 이를 컴포넌트화 해본다면 아래와 같이 함수로 변경할 수 있습니다.

<br/>
<br/>

##### 컴포넌트가 적용된 예시

컴포넌트는 일반적으로 함수를 이용해 작성합니다.

> 클래스 문법을 이용해 작성할 수도 있지만, 함수를 보통 많이 사용합니다.

```jsx showLineNumbers
import React from "react";
import { createRoot } from "react-dom/client";

const text = "I am a paragraph";

function SomeComponent () {
  return <p>I am something else.</p>;
}

function Article() {
  return (
    <div className="something">
      <SomeComponent />
      <p style={{ fontSize: "30px" }}>{text}</p>
    </div>
  );
}

const root = createRoot(document.getElementById("root"));

root.render(<Article />);
```

컴포넌트의 가장 큰 장점은 **재사용성**입니다. 앞으로 만들어 나갈 React Application의 중요한 초석이 되는 부분입니다. 현재 우리가 만든 `Article`이라는 컴포넌트는 항상 같은 UI를 보여주도록 되어있습니다만, React의 다양한 기능을 이용하여 우리는 상황에 따라 다른 내용을 보여주도록 사용할 수 있습니다.

<br />
<br />

### 📘 공식문서

- [당신의 첫 번째 컴포넌트](https://react-ko.dev/learn/your-first-component)

> 공식 문서에 포함된 도전 과제까지 반드시 해보세요.

<br />
<br />

## 컴포넌트 또한 결국 함수

리액트 컴포넌트 또한 결국 함수일 뿐입니다. 그말인 즉슨, 우리가 일반적으로 다루는 로직을 동일하게 적용할 수 있다는 의미입니다.

<br/>

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `// false로 변경하고 Run 해보세요.
const isHappy = true;

export default function App () {
  if (isHappy) {
    return (
      <h1>I am happy.</h1>
    );
  } else {
    return (
      <h1>I am NOT happy.</h1>
    );
  }
}
`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "300px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

위의 로직은 아래와 같이 리팩터링 할 수 있습니다.

<br/>

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `// false로 변경하고 Run 해보세요.
const isHappy = true;

export default function App () {
  return (
    <h1>I am {isHappy ? "happy" : "NOT happy"}.</h1>
  );
}
`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "200px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

<br/>
<br/>

## 조건부 렌더링

방금 위에서 보여드린 예시는 리액트에서 조건부 렌더링을 다루는 방법 중 하나입니다. 조건부 렌더링을 다루는 방법은 여러 가지가 있습니다.

<br/>
<br/>

### Early return

<br/>

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `// false로 변경하고 Run 해보세요.
const isHappy = true;

export default function App () {
  if (isHappy) {
    return (
      <h1>I am happy.</h1>
    );
  }

  return (
    <h1>I am NOT happy.</h1>
  );
}
`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "300px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

<br/>
<br/>

### `null` 활용하기

`null`은 화면에 아무 값도 표시하지 않습니다.

<br/>

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `// false로 변경하고 Run 해보세요.
const isHappy = true;

export default function App () {
  if (!isHappy) {
    return null;
  }

  return (
    <h1>I am happy.</h1>
  );
}
`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "300px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

<br/>
<br/>

### 삼항 연산자와 논리 연산자 활용하기

삼항 연산자와 논리 연산자를 활용하면, 조건부 처리를 할 수 있습니다.

<br/>

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `// false로 변경하고 Run 해보세요.
const isHappy = true;

export default function App () {
  return (
    <>
      <h1>{isHappy ? "I am happy." : "I am NOT happy."}</h1>
      <h2>{isHappy && "I am happy."}</h2>
      <h2>{!isHappy && "I am NOT happy."}</h2>
    </>
  );
}
`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "240px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

> 위 예시에서 `<>`는 [`Fragment`](https://react-ko.dev/reference/react/Fragment)라고 부르는 리액트에서 제공되는 컴포넌트입니다. 왜 사용되었을까요?

<br/>
<br/>

## 컴포넌트 만들어보기

아래 예시에는 `Paragraph`라는 컴포넌트가 사용되고 있지만, 정의되어 있지는 않습니다. `Paragraph`라는 컴포넌트를 만들고, 여러분이 원하는 내용을 렌더링하도록 작성해보세요.

<br/>

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `export default function App () {
  return (
    <>
      <h1>This is title.</h1>
      <h2>This is subtitle.</h2>
      <Paragraph />
    </>
  );
}
`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "240px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

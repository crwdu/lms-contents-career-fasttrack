# 3. Side Effects

# Definition

**"Side Effect"란, 부작용이라는 뜻의 단어입니다.** 프로그래밍에서의 Side Effect란, 어떤 함수가 함수 외부의 정보와 영향을 주고 받는 일을 일컫습니다. Side Effect가 없는 함수는 보통 Pure Function(순수 함수)입니다.

_React에서 Component의 임무는 단 한가지입니다. UI를 그리는 것입니다._

하지만 때로는 UI가 컴포넌트 (React 세상 - root element를 기준으로) 외부 정보에 의존하여 그려질 때가 있습니다. 예를 들면, 서버로 요청을 보내고 그에 따른 응답을 받아서 UI에 보여주어야 하는 경우입니다. 이와 같은 상황에서 서버와 교류하는 네트워크 요청은 React Component 함수 입장에서는 Side Effect라고 할 수 있습니다. 이 외에도 굉장히 많은 종류의 Side Effect가 있을 수 있습니다.

**_📖 useEffect Hook_**

[Using the Effect Hook - React](https://ko.reactjs.org/docs/hooks-effect.html)

# **외부 정보 구독하기**

요즘 수 많은 웹사이트들은 반응형으로 구축되어 만들어집니다. 그리고 Media Query를 이용하여 손쉽게 특정 UI를 숨기거나 보여줄 수 있습니다.

만약에 서버로 요청을 보내야 하는 컴포넌트가 있다고 가정한다면, Media Query는 해당 UI를 화면에서 숨겨주는 역할을 할 수 있지만 서버로 요청이 나가는 자바스크립트 로직에 대한 생략까지 할 수는 없습니다. 그렇기 때문에, 때로는 Media Query가 아닌 자바스크립트를 이용하여 대처하는 것이 더 나은 방법일 수 있습니다. 자바스크립트를 이용한다면, 우리는 UI에 대한 제어와 함께 자바스크립트 로직에 대한 제어 또한 할 수 있습니다.

```jsx
function Paragraph() {
  const mediaQueryList = window.matchMedia("(min-width: 800px)");
  const isWide = mediaQueryList.matches;

  return <p>I am {isWide ? "" : "not"} wide.</p>;
}
```

위 예제에서는 Side Effect가 발생하고 있습니다. **React** 입장에서는 외부 정보인 브라우저 화면 사이즈 정보를 토대로 작업을 하고 있기 때문입니다.

그리고 이 Side Effect는 `Paragraph`가 (굳이 필요하지 않은 상황이 있을 수 있음에도 불구하고) 매번 다시 렌더링 될 때마다 실행됩니다. 다시 렌더링되는 과정은 `Paragraph` 의 부모 컴포넌트가 `Paragraph` 컴포넌트를 다시 렌더링 시키거나, 다른 `state` 값이 변했을때 발생할 수 있습니다.

하지만 `Paragraph` 컴포넌트는 한번 렌더링 된 이후에는 브라우저 사이즈가 변하더라도 다시 렌더링되지는 않습니다. 브라우저 사이즈 변화에 대해 구독하고 다시 `Paragraph` 컴포넌트를 다시 렌더링하는 로직이 없기 때문입니다.

```jsx
function Paragraph() {
  const mediaQueryList = window.matchMedia("(min-width: 800px)");

  // 구독하기
  mediaQueryList.addListener((ev) => {
    console.log(ev.matches);
  });

  const isWide = mediaQueryList.matches;

  return <p>I am {isWide ? "" : "not"} wide.</p>;
}
```

위처럼 수정했을때, 여전히 Side Effect는 `Paragraph` 컴포넌트가 다시 렌더링될때마다 실행되기는 하지만, 적어도 우리는 브라우저의 사이즈 변화에 대해 구독하고 있습니다. 새로운 사이즈 변화에 대한 정보를 우리는 어떻게 저장해야 하고, 어떻게 그 정보를 이용해 UI에 반영할 수 있을까요?

또한 매번 `Paragraph` 컴포넌트가 다시 렌더링되는 과정에서 **계속 쌓이는 구독 신청**은 어떻게 처리해야 할까요?

**🖥 _Example Link_**

[Side Effect](https://codesandbox.io/s/side-effect-40tnz)

```jsx
function Paragraph() {
  const query = "(min-width: 800px)";
  const initialScreenState = window.matchMedia(query).matches;
  const [isWide, setIsWide] = useState(initialScreenState);

  useEffect(() => {
    const media = window.matchMedia(query);

    media.addListener(() => {
      setIsWide(media.matches);
    });
  }, []);

  // rendering..
}
```

위와 같이 수정함으로 해서 우리는 **세 가지**를 얻었습니다.

1. Side Effect는 컴포넌트가 다시 렌더링되는 과정에서 매번 실행되지 않습니다.

2. 구독 신청이 최초 렌더링 한번만 실행됩니다.

3. `isWide`라는 정보를 관리하고 그것을 이용해 UI를 그릴 수 있게 되었습니다.

**🖥 _Example Link_**

[Side Effect 2](https://codesandbox.io/s/side-effect-2-my1br?file=/src/App.js)

하지만 여전히 문제가 하나 남았습니다.

> _위 예제 링크에서 콘솔 메시지의 갯수가 기하급수적으로 증가하는 현상을 확인하셨겠죠? 확인하지 않으셨다면, 다시 위 예제를 실행하여 확인해보세요._

매번 `Paragraph` 컴포넌트가 unmount -> re-mount 되는 과정에서 우리는 listener를 메모리 상에 낭비하게 됩니다. `addListener`를 실행했다면 `removeListener`를 이용하여 뒷정리를 해주어야 하는데, **_새롭게 마운트되는 과정에서 새로운 listener를 등록하기만 할뿐, unmount되는 과정에서 기존 listener에 대한 뒷정리를 하지 않고 있습니다._**

```jsx
useEffect(() => {
  const media = window.matchMedia(query);
  const listener = () => {
    setIsWide(media.matches);
  };

  media.addListener(listener);

  return function cleanup() {
    media.removeListener(listener);
  };
}, [isWide]); // useEffect now runs when `isWide` changes
```

위 예제와 같이 `useEffect` 내부에서 함수(`cleanup`)를 반환하게 되면 해당 함수는 컴포넌트의 Life Cycle에 맞춰 뒷정리 용도로 사용됩니다.

**🖥 _Example Link_**

[useEffect Cleanup](https://codesandbox.io/s/useeffect-cleanup-dd2yn?file=/src/App.js)

**📖 _useEffect_**

_초반에 읽어보셨더라도, 다시 한번 읽어보세요. 특히 effect 정리..!_

[Hooks API Reference - React](https://ko.reactjs.org/docs/hooks-reference.html#useeffect)

# Extra

[useEffect 완벽 가이드](https://overreacted.io/ko/a-complete-guide-to-useeffect/)

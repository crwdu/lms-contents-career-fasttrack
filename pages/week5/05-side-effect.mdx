import { Sandpack } from "@codesandbox/sandpack-react";
import { githubLight } from "@codesandbox/sandpack-themes";

# 사이드 이펙트

> "Side Effect"란, 부작용이라는 뜻의 단어입니다.

프로그래밍에서의 Side Effect란, 어떤 함수가 함수 외부의 정보와 영향을 주고 받는 일을 일컫습니다. Side Effect가 없는 함수는 보통 Pure Function(순수 함수)입니다.

React에서 Component의 임무는 단 한가지입니다. UI를 렌더링하는 것입니다.

하지만 때로는 UI가 리액트 외부 세상에 있는 정보에 의존하여 렌더링 해야 할 때가 있습니다. 예를 들면, 서버로 요청을 보내고 그에 따른 응답을 받아서 UI에 보여주어야 하는 경우입니다. 이와 같은 상황에서 서버와 교류하는 네트워크 요청은 React Component 함수 입장에서는 Side Effect라고 할 수 있습니다. 이 외에도 굉장히 많은 종류의 Side Effect가 있을 수 있습니다.

<br />
<br />

## 리액트 외부 세상이란

리액트 어플리케이션의 초기 구동 코드는 다음과 같습니다. 최상위에 `App`이라는 컴포넌트를 두고, 그 하위에 수 많은 하위 컴포넌트를 두는 구조입니다.

최상위 컴포넌트인 `App` 컴포넌트는 어떻게 렌더링 될까요?

```jsx showLineNumbers {10}
import React from "react";
import { createRoot } from "react-dom/client";

function App () {
  return (
    <div>I am App</div>
  );
}

const root = createRoot(document.getElementById("root"));

root.render(element);
```

리액트의 `createRoot`라는 함수를 이용해 DOM에 리액트 어플리케이션을 마운트합니다. DOM의 `root`라는 id를 가진 요소를 선택하여 해당 요소 내부에 리액트 어플리케이션을 마운트하는 구조가 일반적입니다.

그렇기에 보통 리액트 어플리케이션의 HTML파일을 확인해보면, 다음과 같이 `root`라는 id를 가진 태그가 존재합니다.

```html showLineNumbers {10}
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>React.js</title>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```

> 그렇기에 리액트 외부 세상과의 교류라고 한다면, DOM에서 리액트가 마운트되는 `root` id를 가진 태그를 기준으로 생각했을때 외부 세상이라고 볼 수 있습니다.

사이드 이펙트란, 리액트에서 이런 외부 세상과의 교류를 통해 렌더링을 해야하는 경우를 의미합니다.

<br />
<br />

## 외부 정보 구독하기

요즘 수 많은 웹사이트들은 반응형으로 구축되어 만들어집니다. 그리고 Media Query를 이용하여 손쉽게 특정 UI를 숨기거나 보여줄 수 있습니다.

만약에 서버로 요청을 보내야 하는 컴포넌트가 있다고 가정한다면, Media Query는 해당 UI를 화면에서 숨겨주는 역할을 할 수 있지만 서버로 요청이 나가는 자바스크립트 로직에 대한 생략까지 할 수는 없습니다. 그렇기 때문에, 때로는 Media Query가 아닌 자바스크립트를 이용하여 대처하는 것이 더 나은 방법일 수 있습니다. 자바스크립트를 이용한다면, 우리는 UI에 대한 제어와 함께 자바스크립트 로직에 대한 제어 또한 할 수 있습니다.

<br />

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `export default function Paragraph() {
  const mediaQueryList = window.matchMedia("(min-width: 100px)");
  const isWide = mediaQueryList.matches;

  return <p>I am {isWide ? "" : "not"} wide.</p>;
}`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "240px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

위 예제에서는 Side Effect가 발생하고 있습니다.

1. **React** 입장에서 **브라우저** 화면 사이즈 정보는 `root` 태그를 넘어선 외부 세상이라고 할 수 있습니다.
2. **컴포넌트가 렌더링을 하는 과정**에서 외부 세상의 정보를 필요로 하고 있습니다.

이 두 가지가 모두 충족될 경우, 우리는 사이드 이펙트라고 할 수 있습니다.

<br />
<br />

그리고 이 Side Effect는 `Paragraph`가 (굳이 필요하지 않은 상황이 있을 수 있음에도 불구하고) 매번 다시 렌더링 될 때마다 실행됩니다. 다시 렌더링되는 과정은 `Paragraph` 의 부모 컴포넌트가 `Paragraph` 컴포넌트를 다시 렌더링 시키거나, 다른 `state` 값이 변했을때 발생할 수 있습니다.

하지만 현재 위의 예시 코드에서 작성된 `Paragraph` 컴포넌트는 최초 한번 렌더링 된 이후에는 브라우저 사이즈가 변하더라도 다시 렌더링되지는 않습니다. 브라우저 사이즈 변화에 대해 구독하고 다시 `Paragraph` 컴포넌트를 다시 렌더링하는 로직이 없기 때문입니다.

<br />
<br />

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `export default function Paragraph() {
  const mediaQueryList = window.matchMedia("(min-width: 200px)");

  // 구독하기
  mediaQueryList.addListener((ev) => {
    console.log(ev.matches);
  });

  const isWide = mediaQueryList.matches;

  return (
    <>
      <p>I am {isWide ? "" : "not"} wide.</p>
      <p>아래 코드샌드박스에서 실행하여 브라우저 창 크기를 조절하며 콘솔창을 확인해보세요.</p>
    </>
  );
}`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "440px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

위처럼 수정했을때, 여전히 Side Effect는 `Paragraph` 컴포넌트가 다시 렌더링될때마다 실행되기는 하지만, 적어도 우리는 브라우저의 사이즈 변화에 대해 구독하고 있다는 사실을 콘솔 출력문을 통해 확인할 수 있습니다. 새로운 사이즈 변화에 대한 정보를 우리는 어떻게 저장해야 하고, 어떻게 그 정보를 이용해 UI에 반영할 수 있을까요?

또한 매번 `Paragraph` 컴포넌트가 다시 렌더링되는 과정에서 **계속 쌓이는 구독 신청**은 어떻게 처리해야 할까요?

<br />
<br />

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `import { useState, useEffect } from "react";

export default function Paragraph() {
  const query = "(min-width: 200px)";
  const initialScreenState = window.matchMedia(query).matches;
  const [isWide, setIsWide] = useState(initialScreenState);

  useEffect(() => {
    const media = window.matchMedia(query);

    media.addListener(() => {
      setIsWide(media.matches);
    });
  }, []);

  return (
    <>
      <p>I am {isWide ? "" : "not"} wide.</p>
      <p>아래 코드샌드박스에서 실행하여 브라우저 창 크기를 조절하며 콘솔창을 확인해보세요.</p>
    </>
  );
}`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "540px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

위와 같이 수정함으로 해서 우리는 **세 가지**를 얻었습니다.

1. 현재 우리의 Side Effect는 컴포넌트가 다시 렌더링되는 과정에서 매번 실행되지 않습니다.
2. 미디어 쿼리에 대한 구독 신청이 컴포넌트 최초 렌더링 한번만 실행됩니다.
3. `isWide`라는 정보를 관리하고 그것을 이용해 UI를 그릴 수 있게 되었습니다.

<br />
<br />

### useEffect Hook

#### Parameter

1. 함수: 사이드 이펙트 로직을 담고 있는 함수입니다. 컴포넌트 최초 렌더링시에 1회 실행되고, 그 이후에는 의존성 배열에 따라 실행 타이밍이 제어됩니다.
2. 의존성 배열: 1번의 함수가 실행되는 타이밍을 제어하는 의존성 배열입니다. 의존성 배열에 나열된 요소들이 변경되어 컴포넌트가 렌더링되면 1번 함수가 다시 실행됩니다.

> 방금 위의 예시에서는 의존성 배열이 비어있기 때문에, 최초 1회만 실행됩니다.

하지만 여전히 문제가 하나 남았습니다.

<br />
<br />

<Sandpack
  template="react"
  theme={githubLight}
  files={{
    "/App.js": {
      code: `import { useState, useEffect } from "react";

function Paragraph() {
  const query = "(min-width: 200px)";
  const initialScreenState = window.matchMedia(query).matches;
  const [isWide, setIsWide] = useState(initialScreenState);

  useEffect(() => {
    const mediaQueryList = window.matchMedia(query);

    console.log("Component mounted and adding listener..");

    mediaQueryList.addListener(() => {
      console.log("Component state change..");
      setIsWide(mediaQueryList.matches);
    });
  }, []);

  return <p>I am {isWide ? "" : "not"} wide.</p>;
}

export default function App() {
  const [showParagraph, setParagraphVisibility] = useState(false);

  return (
    <div>
      <h1 onClick={() => setParagraphVisibility(!showParagraph)}>
        클릭하고, 화면 사이즈를 조정하고, 다시 클릭해보세요.
      </h1>
      {showParagraph && <Paragraph />}
    </div>
  );
}`,
      active: true
    }
  }}
  options={{
    showLineNumbers: true,
    editorHeight: "740px",
    editorWidthPercentage: 60,
    initMode: "lazy",
    autoReload: false,
    showConsoleButton: true,
  }}
  customSetup={{
    entry: "index.js",
  }}
/>

> 위 예제 링크에서 콘솔 메시지의 갯수가 기하급수적으로 증가하는 현상을 확인하셨겠죠? 확인하지 않으셨다면, 다시 위 예제를 실행하여 확인해보세요. 자세히 확인하고 싶다면, 코드샌드박스 링크를 활용해보세요.

<br />
<br />

매번 `Paragraph` 컴포넌트가 unmount -> re-mount 되는 과정에서 우리는 listener를 메모리 상에 낭비하게 됩니다. `addListener`를 실행했다면 `removeListener`를 이용하여 뒷정리를 해주어야 하는데, **_새롭게 마운트되는 과정에서 새로운 listener를 등록하기만 할뿐, unmount되는 과정에서 기존 listener에 대한 구독 뒷정리를 하지 않고 있습니다._**

```jsx
useEffect(() => {
  const media = window.matchMedia(query);
  const listener = () => {
    setIsWide(media.matches);
  };

  media.addListener(listener);

  return function cleanup() {
    media.removeListener(listener);
  };
}, [isWide]); // useEffect now runs when `isWide` changes
```

위 예제와 같이 `useEffect` 내부에서 함수(`cleanup`)를 반환하게 되면,

1. 의존성으로 주어진 `isWide` 상태가 변경되어 컴포넌트가 리렌더링 되기 전에, `cleanup` 함수가 실행됩니다.
2. 컴포넌트가 리렌더링 됩니다.
3. 사이드이펙트 함수가 다시 실행됩니다.

<br />
<br />

### 📘 공식문서

- [Effect와 동기화하기](https://react-ko.dev/learn/synchronizing-with-effects)
